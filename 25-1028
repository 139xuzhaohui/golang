- 数据库的连接
- spring里面的 transactionTemplate 和 transactional的注解的区分
- spring 如何与 mybstis 或者 jdbc 使得事务生效的呢？
- 数据同步 - jingwei ，如何做的不延迟！ --好像还是有延迟的... 【对于事务消息 binlog 又是怎么做的呢？】 数据同步啥的，最好还是看看 比如jinw的实现 
- 对于秒杀场景的话， 是先扣减 对吧， 那怎么加一呢？ 这个资源回补的case - 怎么解决呢 ，日志采集-mq，进行商品前置处理！ 前置流量清洗， 应用清洗，直到最后一步才会有sentinel进行限流，
- 顺序消息 -分区内有序, 还是队列里面有序吗？ 
- 限流方式！！！负载均衡算法， 这些也还要了解哇！ RateLimiter ？ 
- mapreduce 的思想，多机器下任务控制 并发 并行 如何保证
- 弹幕、点赞、这种高并发场景！



【分布式CAP理论--及目前协调组件的常用的协议】
-  zk ： 协议是 ZAB 类似 Paxos 的原子广播协议， 用于一致性和选举leader； 【CP】 强一致性，在无主 或者 多数不可达 的情况下，则会出现不可用状态，-拒绝写入，但是读还是可以的！

-   比如dubbo， 但是现在 dubbo可以支持多种的注册中心， zk、nacos、还有和 kubernetes service的

- etcd ： 键值对存储、服务发现和配置管理，Kubernetes 默认用它作为存储后端。 用到的协议是 raft， Raft —— 一种比 Paxos 更容易理解和实现的共识算法，确保多数节点达成一致。 【CP】 强一致性， 
     一般用户 k8s

- consul: 服务发现、注册中心、健康检查、Key/Value 配置存储,  用到的协议是 raft, 【CP】 强一致性 或者【AP】 高可用性 ， 但是对于服务发现是 通过 Gossip 协议传播节点信息，Gossip 属于 AP（可用性优先）。

- Nacos : 协议是【Raft+Distro】 ，配置中心 CP，服务发现 AP 

- Eureka ： 服务注册与发现（Spring Cloud 早期默认），【AP】 高可用性 ，写入和读取只要节点活着就会成功。

-- 对于集群的模块 比如 redis 他的三种集群模式， 对于哨兵Sentinel 主要是：简单的哨兵投票选举（基于多数票，无复杂共识协议）。 Cluster：用于分片的 gossip 协议 和投票 ； 集群模式是 【AP】


【比较一下几种 分布式协议 里面实现的共识算法的区别】

- Paxos 对于leader而已是动态的， 每个人都可以是leader，都可以提案， 【多数派接受提案】，多用作于 元数据一致性、协调服务
- ZAB。主打一个原子广播，事务顺序+可靠性 ; 基于ZXID、最新的事务id 来选取最新的数据节点当leader，【多数派事务确认】 新的leader会和多数派进行对齐 事务日志，然后恢复可用性， 读数据的话 支持follow或者leader
- Raft  主要靠日志复制 和强一致性共识; 基于日志索引 + 任期号 Term ; 【多数派日志确认】新的leader呢 会直接拒绝-过期的日志，向多数派同步自己的日志 （这样感觉raft会强硬一些），  读都默认走leader
- Gossip（非强一致）	 --没有leader， 最终一致性 - 基于消息传播-节点在线即可; 

----
共识/选举算法用来在多节点环境下选出一个合法的 Leader，
并保证所有节点的数据和操作顺序完全一致，如 Paxos、Raft、ZAB 都是典型的强一致性（CP）算法。它们的可用性条件是：Leader 存在且能联系到多数派节点。
当 Leader 不存在或多数派不可达时，强一致读写不可用，但弱一致读仍可能返回旧数据。
功能定位不仅是选主，还包括分布式锁、日志复制、元数据管理、任务调度等。强一致性的代价是牺牲可用性，但在必须保证数据绝对正确的场景（如注册中心、元数据存储、分布式锁）非常重要。
----


---- 拓展知识
再补充一下，为啥大家很少看到直接用paxos的， 一个原因是，paxos是动态选主的，
动态 Leader 和固定 Leader的区别在于 Leader 的稳定性和选举频率:
动态 Leader（如经典 Paxos）是在每次共识提案时临时选出提案者作为 Leader，提案结束角色就结束； --- 开销大 -- 并发大的时候会频繁选举
而固定 Leader（如 Raft、ZAB、Multi-Paxos）则在系统运行中选出一个长期负责写入的 Leader，只有在它失效时才重新选举。固定 Leader 减少了频繁的选举过程，性能更好，冲突少，但依赖 Leader 的稳定性。
-------


【什么是共识 / 选举算法】

在分布式系统中，多个节点必须就某个状态、值或操作的执行顺序达成一致，这个过程就是共识（Consensus）。
主要共识 有两种： 
 一个主 - Leader-based 
 无主 - Leaderless

常见共识算法：
比如: 
1、Paxos：理论上最经典、最严谨的共识算法。
2、Raft：对 Paxos 的工程化简化版，易于实现。
3、ZAB（Zookeeper Atomic Broadcast）：为 Zookeeper 定制的共识与广播协议。
4、Multi-Paxos：Paxos 的优化版本，用 Leader 长期主导，减少选举次数。
5、Viewstamped Replication (VR)：早期协议，思想类似 Raft。

这些共识/选举算法的功能不只是“选主”， 它们在系统中能承担很多通用 的 【分布式协调任务】
比如:
1、Leader 选举
   在多个节点中选择一个作为服务的主控（Master/Leader），其余作为 Follower。
2、日志复制
   Leader 接收操作日志，复制到其他节点，并保证顺序和一致性。
3、状态机复制（SMR）
  将一系列操作按严格相同顺序应用到所有节点，保证每个节点的状态一样。
4、分布式锁管理
  通过强一致的元数据维护互斥控制。
5、元数据/配置管理
   保证全局元数据一致，比如注册中心的服务列表。
6、任务调度与协调
   例如谁来负责处理特定分区的数据。

📌 简单来说：共识算法解决的是“多节点如何确定唯一的真相”，所有依赖唯一真相的场景都可以用它


强一致性共识算法（CP 系统）的可用条件
   满足两个条件才能提供强一致读/写：
     1、Leader 存在并已确认合法（选举完成且没有竞争）
     2、Leader 能与多数派节点通信并得到确认（quorum）

📌 多数派计算方法： 必须要>=⌊N/2⌋+1 ,才叫多数派



 理解一下 【网络分区】和多数不可达

 网络分区 --最容易出现的是双主，某一个部分的集群和 主节点之间的通信没了， 就会触发选举， 双主出现后...对于apcp 会有怎么样的做法呢？
 多数不可达 -- 是指 主节点在同步数据的时候， 一直不成功 大多数的响应没有拿到 -- 这样理解对吗？

强一致性和不可用，这个得说明一下，如果读的时候 可以接受弱一致性的话，那么还是可用的， 但是不接收的话 则是不可用状态


最终：

CAP。AP。CP
Paxos。raft。zab。gossip...
zk (cp) 、ectd(cp) 、consul(ap+cp)、nacos(ap+cp)、 eureka（ap）、 

基本的选举过程的话， 有点不知道... 
 

分布式锁 为啥 使用redis呢？ 而不用zk啥的， 网络io的消耗， 其次对于锁的实现，zk的毕竟需要集群间的同步，类似于其他的， 而redis的话 更为轻便一些。可以这样说吗？



