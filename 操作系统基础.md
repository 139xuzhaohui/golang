# UNIX体系结构
## - 什么是内核

> 从严格意义上说,可将操作系统定义为一种软件, **它控制计算机硬件资源,提供程序运行环境**。
> - 我们通常 **将这种软件称为内核(kernel)**,因为它相对较小, 而且位于环境的核心
> - 内核的接口被称 **为系统调用(system call**),图1-1中的阴影部分)。
> - **公用函数库 构建在 系统调用接口之上 ** , 应用程序既可使用公用函数库【库函数】,也可使用系统调用。 == 比如 LIUNX 是 GUN操作系统 使用的内核
> -  shell 是一个命令解释器 or 终端交互 shell脚本

<img width="300" height="350" alt="image" src="https://github.com/user-attachments/assets/5223908f-be5d-40a5-ae94-81ab6b90a1c7" />


## 1、 文件和目录

### 文件系统
 - 目录也是文件 只是包含了些 目录项
 - stat 和 fstat 会返回 文件的一些信息
### 文件名 filename
- . 和 .. 也是文件名, 创建新目录时候 会默认创建这个两个文件名，
- >  .指向当前目录 而.. 则是父目录
  > 可以参考命令 # *cd ..*
### 路径名
- ls 一般都以 文件名顺序列出
对于操作目录  readdir、opendir 、 closedir

## 2、输入和输出
> 文件描述符 fd 小的非负整数   todo是为了 表示 在读、在写???
> - 主要是: 标准输入、标准输出 、 标准错误 
> - ls > test.txt  == 将ls 里的 dd 都输入到 test.txt 里面
> - 什么 是 不带缓冲的 IO，TODO  --系统io

## 3、进程和程序
> **程序 是一个 可执行文件, 程序的执行实体被称为 process进程**，每一个process 都会有个PID 【 **getpid()** 】
> 进程和进程ID
> 进程控制: 主要有三个函数 **exec、fork、waitpid**
- > 调用 **fork 创建一个新进程** 。 新进程是 **调用进程的一个副本**
  > 我们称调用进程为父进程, 新创建的进程为子进程。
  > fork对父进程返回 **1、新的子进程的进程ID(一个非负整数),对子进程则返回0**。 因为fork创建一个新进程,所以说它被调用一次(由父进程),但**返回两次(分别在父进程中和在子进程中)**。
 
### 子进程 和 父进程
在子进程中,调用 execlp 以执行从标准输入读入的命令。这就用新的程序文件替换了子进程原先执行的程序文件。
- **fork** 和跟随其后的 **exec** 两者的组合就是某些操作系统 **所称的产生(spawn)一个新进程**。
- 在UNIX系统中, 这两部分分离成两个独立的函数。第 8章将对这些函数进行更多说明。
- 子进程调用 **execlp** 执行新程序文件,而*父进程希望等待子进程终止*,这是通过调用 **waitpid** 实现的，其参数指定要等待的进程(即pid 参数是子进程ID
- waitpid函数返回子进程的终止状态(status 变量)

> fgets 遇到换行符会终止读取

### 线程 和 线程id
 **一个进程内的所有线程共享 同一地址空间、文件描述符、栈 以及与进程相关的属性**, 因为它们能访问同一存储区,所以各线程在访问共享数据时 *需要采取同步措施以避免不一致性*
  与进程相同,线程也用ID标识。但是,线程ID*只在它所属的进程内起作用*。
  一个进程中的线程 ID 在另一个进程中没有意义。当在一进程中对某个特定线程进行处理时,我们可以使用该线程的ID引用它。

## 4、出错处理
当UNIX 处理出错的时候， 通常会返回一个负数

## 5、用户标识
- 用户id 和 组id ；UserId 和 GroupId

## 6、信号
- signal 函数
- 因为大多数重要的应用程序都对信号进行处理,所以第10章将详细介绍信号。
## 7、时间值
 time()
- 当度量一个进程的执行时间时(见3.9节),UNIX系统为一个进程维护了3个进程时间值:
- 时钟时间;
- 用户 CPU时间;
- 系统CPU时间。

## 8、系统函数和库调用
- malloc 分配存储空间











