怎么昨天没有写呢？
 - 数据库
 - 限流算法
 - mq
 - io -好难
 - 读写扩散
 - 缓存一致性
 -  memcached 和 redis 的区别 ???? [缓存中间件]
 -  mongdb 和 mysql ---好像引擎就不一样诶，😩 😧都忘记惹， 

<br>

#### 缓存一致性

结论：
> 对于一个不能保证事务性的操作，**一定涉及“哪个任务先做，哪个任务后做”的问题** ，解决这个问题的方向是：**如果出现不一致，谁先做对业务的影响较小，就谁先执行**。


- 不管怎么样，要么先写db-在写cache，要么先写cache-再写db， 不考虑并发问题，两者都可以保持数据一致， 
但是如果异常了，A 成功 b失败，此时就会有问题了， 或者 a失败了 b成功了--- 这种是 删cache 写db 在回写cache
【生产里的】 嗯.... 一般是insert到db 再去更新cache --接受延迟！ 得保证db里面的和cache是一样的！【统计参与人数！】
如果删除缓存失败，or 更新失败了 
 **重试大法!!!** <br> 无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」。

**缓存 有可能 回种旧值** 并发case，除非在delete的原子上保证 update成新值
但是我想 会有写完数据库，b来读还是旧值吗？ 因为我们是 insert or update 之后去delete的，---并发case下

延迟删除，-- 等数据库更新之后，放到队列里面 等一会去更新缓存的值，---这样至少保证了最终一致性，当然你也可以合并操作

这里可以回头来谈一下 为啥要用缓存，如果缓存要【强一致性】，避免不了 就要加锁，让大家一起执行，or 重试回补，
如果仅仅是【避免频繁访问】 --是不是可以接受一定时间的延迟

还有**延迟双删**， 
第一次删除缓存数据==>更新数据库==>等待1~5s==>第二次删除缓存数据 
很复杂吧， 
- 感觉还是要看 具体的业务场景
- 活动的参与人数
 
就很像操作系统的 事件总线， 
MESI 和 ESI
表示的四个状态
modify， exclusion，share， ignore吧 好像是


#### base理论
BASE 理論本質上是對 CAP 的延伸和補充，更舉體來說是對 AP 方案的一個補充;
通过一定时间的延迟---来保证最终一致性！！
Basically Available 、 Soft State 、 Eventual Consistency


#### 读写扩散

> 读扩散, 指牺牲了读的性能, 去提升写的性能.  每个人都本地冗余一份吧！
> 而写扩散, 一般指牺牲了写的性能, 去提升读的性能.

**查询驱动(query-driven)的设计原则**
读写路径的观点参考自 《数据密集型应用系统设计》， **读写路径的博弈** 
既然 "读路径" 太长, 我们就可以通过延长 "写路径", 来缩短 "读路径". 
既然 “写路径” 太长的话，我们可以延长 读路径的 方式来缓解

> 拉取大V的动态
> 推送小v的动态

--- 一个人的朋友圈 就很像一个人的购物车，只是这个购物车是否可以被分享or被看到，
有点子像吧， 比如可以使用nosql 【主要的场景是mongdb来保存购物车的一个数据，--但是购物车不是频繁更新么？】来保存我关注的人or关注我的人, 
