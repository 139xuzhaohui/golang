tooooooo fast

分片/跑批/并行/网格

### 调度 

- 单机
- 广播
- 轮训
- Map 并行、内存网格、网格计算
- map reduce， 内存网格？
- 分片 就是Map内存网格计算的推模式？？？
- Map执行方式的差异点:
● 并行计算
   ○ task信息保存在个Map中
● 内存网格
  ○ task信息保存在H2 Memory
● 网格计算
 ○ task信息保存在H2 File

### 调度模式

● 单机：随机挑选一台机器执行。 --- 可以理解成顺序，没有并发！单线程

● 广播：所有机器同时执行且等待全部结束。  
   任意一台worker执行失败，都算该实例失败。所有worker执行成功，才算该实例成功。 ---有这样的任务吗？？
    比如跑脚本/清缓存/数据聚合啥的
   
● Map模型：类似于hadoop mapreduce里的map。只要实现一个map方法，简单几行代码就可以将海量数据分布式到客户自己的多台机器上执行，进行跑批。
● MapReduce模型：MapReduce模型是Map模型的扩展，废弃了postProcess方法，新增reduce接口，
    所有子任务完成后会执行reduce方法，可以在reduce方法中返回该任务实例的执行结果，或者回调业务。
● 分片运行：类似于elastic-job的分片模型，控制台配置分片参数，
    可以将分片平均分给多个客户端执行，支持多语言版本。


### 调度算法

#### 以下更偏向于OS,
 cfq，叫做完全公平队列调度
 deadline
 noop  --fifo


#### 以下更偏向于 负载均衡
感觉总结下来就是 ==  【轮训】、【加权】、【一致性hash(只是大家的一致性的因子不一样)】

 - RR 轮询啦 ， 可以加 随机因子 做调衡
 - WRR 加权轮询调度算法，嗯...加入了占比的这个概念--下标，1-6都是1，其他是2,3
 - WLC 加权最小连接数调度算法 （后端服务器列表中选取**连接数加权最小的**服务器进行调度。每一次调度都会实时的去计算所有后端服务的连接加权值）
   相比较而言！！！准全局的调度算法，因此它的调度均衡性最好，demo 每次都要算噢，
 - QCH 一致性哈希调度算法
   是基于：**QUIC**  Connection ID一致性hash，相同的QUIC Connection ID会调度到相同的后端服务器。
 - TCH 一致性哈希调度算法
   四元组的一致性hash（源IP+目的IP+源端口+目的端口）调度算法，相同的流会调度到相同的后端服务器。
- SCH (Source IP  based Consistent Hash) 一致性哈希调度算法
- 

***
在**PUSH模式下**，Master主动将内存队列中的任务推送给Worker，
Worker接收到消息后开启ThreadContainer容器执行用户自定义的Processor。
如果是Map模型下首次创建的根任务，则由Master自己执行，得到子任务后继续放入内存队列中，继续推送给Worker执行。这样就形成了Master->Worker->Master的任务执行闭环。

绿色箭头是**PULL模式下**的任务拉取方式。在拉模型下，
Master发送事件通知各Worker开启Pull线程，Worker主动从Master的内存队列中拉取消息

***
---
> **H2** --基于java写的轻量型的数据库
> 纯Java实现：无需额外安装 ， 多种模式：内存、嵌入式、服务器模式；
> 默认是 会持久化，内存--就不是持久化的，要么文件 要么是网络进行存储在别的服务器上！

***

> **DAG**是有向无环图（Directed Acyclic Graph）的缩写。
> 它是一种用于描述多个任务之间依赖关系的图形结构，
> 其中节点表示任务，边表示任务之间的依赖。
> **DAG中的所有边都是有向的，且不会形成环路** == 这意味着任务必须按照特定的顺序进行，以确保依赖关系正确。

***
> RocketMQ的定时消息是如何实现的呢？
> 在RocketMQ中，使用了经典的**时间轮算法**。通过TimerWheel来描述时间轮不同的时刻，通过TimerLog来记录不同时刻的消息。

#### 时间轮？？？---母知
HashedWheelTimer 是netty中针对时间轮算法的成熟实现

#### 消息投递
一般而言，消息投递有下面三种情况：
**at-most-once** 意味着每条应用了这种机制的消息会被投递0次或1次。**可以说这条消息可能会丢失**。
**at-least-once** 意味着每条应用了这种机制的消息潜在的存在多次投递尝试并保证至少会成功一次。**就是说这条消息可能会重复但是不会丢失**。
**exactly-once** 意味着每条应用了这种机制的消息只会向接收者准确的发送一次。换言之，**这种消息既不会丢失也不会重复**。

-- 想一想，mq为啥可以保证 at-least-once ， how ？？？ --其实大部分都是这样实现的，
**三大part**  【持久化】【ack】【自动重试】
想要实现AtLeastOnce语意，有以下几个必要条件：
- 1.持久化
  Akka须持久化使有状态的actor能保留它的内部状态，因此我们不会因为JVM崩溃、actor异常关闭等问题导致数据丢失。
-2.ACK
  当actor向目标发送消息后，需要目标回复ACK来保证目标一定成功接收到了消息。
-3.自动重试
  没有收到目标ACK时，提供将未确认的消息自动重新投递的机制。
