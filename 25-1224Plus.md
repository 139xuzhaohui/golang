# OS-comand.md

## FOR IO

**文件IO(系统调用IO)** 是 **每次** 操作都会执行系统调用, **标准IO**实现了进程内数据缓存,*【并不会每次】都直接执行系统调用*
- 1. **系统I/O (System I/O)** == 就是 **无缓冲I/O**
> 直接调用操作系统内核提供的系统调用，数据直接在**用户空间和内核空间**之间传输。
``` c
//  系统I/O示例
int fd =  open ("file.txt", O_RDONLY);
char buffer[1024];
ssize_t bytes_read = read(fd, buffer, sizeof(buffer));  // 直接系统调用
close(fd);

特点：
- 每次调用都进入内核态 == *意味着每次都会状态切换*
- 没有用户空间缓冲 
- 性能开销大（频繁系统调用）
- 数据立即写入/读取
```

- 2. **标准I/O (Standard I/O)**  - **带缓冲I/O**
> C标准库提供的I/O函数，在**用户空间维护缓冲区** ， f开头....
```c
// 标准I/O示例
FILE *fp = fopen("file.txt", "r");
char buffer[1024];
size_t bytes_read = fread(buffer, 1, sizeof(buffer), fp);  // 库函数调用
fclose(fp);

特点：
- 用户空间有缓冲区
- 减少系统调用次数 
- 性能更好
- 三种缓冲模式 (全缓冲、行缓冲、无缓冲)
```



###  fd -- 文件描述符，是贯穿文件IO始终的类型
  - 文件描述符的概念（实质是一个整数，是数组的下标，文件描述符优先使用当前可用范围内最小的）
	- 数组存放在**进程空间**的，每个进程都有这样一个数组，不同的进程打开同一个文件，每个进程都会有**一个文件结构体**，但最终指向的inode文件唯一标识符是相同的。
	- 由于两个结构体在不同的进程中，所以两个结构体是互相不影响的，**但最终操作的是同一个文件，会产生竞争和冲突问题**。
	- 同一个文件在一个进程中被打开多次，**每次都会产生一个结构体**，结构体之间也不会互相影响（甚至可以相互配合配合对文件进行读写）.
	既然数组中存放的是结构体的地址，那么有可能不同的数组下标存放的是同一块结构体的地址（如下标3、5存放的结构体地址相同），
    那么在关闭后，结构体内存并不会立即释放（如果立即释放，则下标5的指针就成为了野指针），
  - 那么就要求结构体肯定有一个**引用计数**，*表示当前有几个指针指向它自己*，
	- 只有当引用计数为0时，才真正释放这块内存区域。

标准IO的 **FILE结构体** 肯定会有系统IO中的文件描述符标志，
== **因为标准IO是建立在系统IO之上** ，系统IO每个文件的打开都会有**系统IO的结构体和文件描述符**。
> 结构体 struct 和 文件描述符 fd  【包含标准IO和系统IO】

###  标准IO 和 系统IO 
> 还有🤣个文件IO ， == 底层其实就是标准和系统， 至于 文件I/O主要是看io操作的内容是什么 还有网络io 

- linux有**标准IO**和**系统IO**两种，它们最大的区别就是 **标准IO减少了系统调用次数**
- 标准IO 是什么?
- 系统IO 是什么?
- 文件IO 是什么?

### 文件IO
- 可用的文件IO函数--打开、读、写等。
- linux大多数文件IO只需用到5个函数：**open、read、write 、lseek 、close **，然后说明 **不同缓冲区长度**对read和write函数的影响。
- 本章所说的函数被称为不带缓冲的IO，与标准IO相对应，它是指每次read和write时立即调用内核中的系统调用。
- 涉及到多个进程间共享资源，原子操作的概念就变得非常重要。将通过文件IO和open函数的参数来讨论此概念。

> ps:
> - 文件io函数 **针对文件描述符**，而标准io是围绕**流**进行的。
> - 经常使用的都是标准IO，其有缓冲区，有三种缓冲模式：**全缓冲、行缓冲、无缓冲**

### 文件IO和标准IO的区别
	- 两者转换函数 fileno(); fdopen();
  - 虽然可以相互转换，**标准IO**与 **文件IO** 不可混用，为什么？

###  文件共享
	题目：写程序，删除一个文件的第10行。可以在一个进程或多个进程中打开同一个文件，一个对其读，一个对其写。
	补充函数： truncate/ftruncate 【clean命令】
  

#### 文件IO操作：open,close,read,write,lseek (之前的标准IO都是依赖这几个函数)
- int open(const char *pathname, int flags);
- **（cache是加速读的机制，buffer是加速写的机制）**
- 参数flags必须包含以下模式的其中之一：O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（读写）。
- 另外文件创建模式的flags和文件状态模式的flags可以任选0个或多个进行按位或运算，来作为flags。
- 文件创建模式的flags有：O_CREAT（文件存在则创建）、O_EXCL（配合O_CREAT，如果文件已经存在则报错）、O_TRUNC（文件截断）、O_APPEND（追加写）



##### 共享文件 what is that：
关键有三个表：
1. 【**文件描述符表**】： 每个进程都有这么一张表，表项的数据包含fd和指向文件表项的指针
2. 【**文件表**】： 文件每次被打开，就会在这个表中生成一条表项。表项的数据包含：文件状态标志（读、写、追加写、同步、非阻塞等）
	和当前文件偏移量、指向文件v节点表项的指针。
3. 【**v节点表**】：每个打开的文件，不论被打开几次，都只生成一条v节点表项。
	v节点表项包含：文件类型和对此文件进行各种操作的函数的指针信息。大部分文件还包含了i节点信息，
	而i节点则包含文件所有者、文件长度、所在设备等。

> **由fork产生的父子进程，由于子进程完全复制父进程的一切**，因此子进程的文件描述符表和父进程相同，而他们的文件表项是相同的，

##### 原子操作
> - 原子：不可分割的最小单位
> - 原子操作：不可分割的操作
> - 作用：解决竞争和冲突
> - 样例：tmpnam（只给一个文件名）tmpfile（）

##### 程序中的重定向： dup, dup2
- 在代码中要将一个puts输出到指定文件，则需要将stdout重定向。
- 可以先关闭1的文件，再打开fd，这样用的就是1号。（但如果没有1号怎么办？） ---这是在讲森么 todo
- int dup2(int oldfd, int newfd); 是原子操作


##### 同步：sync, fsync, fdatasync
- todo 这几者的区别
- 将设备解除挂载时刷新buffer
- fdatasync：同步一个文件，只刷数据，不刷亚数据

### 标准IO
> c 实现的，不是系统的--但是底层应该调用的是系统的吧？？？？ todo
> **标准IO**有如下几个函数：
> 大部分以f开头 --- 是有啥 TODO 特殊含义么
- fopen()
- fclose()
- > fclose() **只刷新用户空间的缓冲区**。为了保证数据保存在磁盘上需要 **刷新内核缓冲区。如使用sync或者fsync**.
- fgetc()
- fputc()
- fgets()
- gputs()
- fread()
- > size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
  > size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
  > 返回成功读或写操作的对象个数  **缺点: 什么是并没有限制边界？什么含义？todo**
  
- fwrite()

- printf()
- scanf()
- > 目前位置，**没有任何一个函数，能够从一个流中获取任意大小字节数据**，fgets和fread都有size的限制，一次不能超过size个，不能想取多少取多少。
  
- fseek()
- ftell()
- fseek和ftell（fseeko和ftello）
- rewind()

- **fflush()**
