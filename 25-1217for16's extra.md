
<img width="1586" height="544" alt="image" src="https://github.com/user-attachments/assets/5e509940-6014-4705-b673-7448b9d48e5d" />

> Q: 相对声明式语言，命令式语言有什么优点？
- 当描述的目标变得复杂时，声明式表达能力不够。【命令式 -- 重逻辑过程 ，step1or2、then3and4、...., 而声明式 就是 1怎么样2就怎么样 强逻辑sunbathing吧】
- 实现命令式的语言往往不会和声明式那么泾渭分明，通过合理抽象，通过一些编程范式（函数式），可以让代码兼顾表达力和清晰性。


### SSTable（Sorted String Table）。

高效的数据文件合并。即有序文件的归并外排，顺序读，顺序写。不同文件出现相同 Key 怎么办？
不需要在内存中保存所有数据的索引。仅需要记录下每个文件界限（以区间表示：[startKey, endKey]，当然实际会记录的更细）即可。查找某个 Key 时，去所有包含该 Key 的区间对应的文件二分查找即可。
分块压缩，节省空间，减少 IO。相邻 Key 共享前缀，既然每次都要批量取，那正好一组 key batch 到一块，称为 block，且只记录 block 的索引。


### 从 SSTables 到 LSM-Tree
> 如果想让一个引擎工程上可用，还会做大量的性能优化。对于 LSM-Tree 来说，包括：
1. 优化 SSTable 的查找。常用 Bloom Filter。该数据结构可以使用较少的内存为每个 SSTable 做一些指纹，起到一些初筛的作用。
2. 层级化组织 SSTable。以控制 Compaction 的顺序和时间。常见的有 size-tiered 和 leveled compaction。LevelDB 便是支持后者而得名。前者比较简单粗暴，后者性能更好，也因此更为常见。


对于 RocksDB 来说，工程上的优化和使用上的优化就更多了。在其 Wiki 上随便摘录几点：

1. Column Family
2. 前缀压缩和过滤
3. 键值分离，BlobDB
但无论有多少变种和优化，LSM-Tree 的核心思想—— **保存一组合理组织、后台合并的 SSTables** ——简约而强大。 **可以方便的进行范围遍历，可以变大量随机为少量顺序**

### B 族树

> 虽然先讲的 LSM-Tree，但是它要比 B+ 树新的多。 *== 等同于 LSM-Tree 要年轻些*
> B 树于 1970 年被 R. Bayer and E. McCreight 提出后，便迅速流行了起来。现在几乎所有的关系型数据中，它都是数据索引标准一般的实现。
> 与 LSM-Tree 一样，它也支持**高效的点查和范围查**。但却使用了<ins>完全不同的组织方式</ins>

**其特点有：**

以页（在磁盘上叫 page，在内存中叫 block，通常为 4k）为单位进行组织。
页之间以页 ID 来进行逻辑引用，从而组织成一颗磁盘上的树。


查找。从根节点出发，进行二分查找，然后加载新的页到内存中，继续二分，直到命中或者到叶子节点。查找复杂度，树的高度—— O(lgn)，影响树高度的因素：分支因子（分叉数，通常是几百个）。


插入 or 更新。和查找过程一样，定位到原 Key 所在页，插入或者更新后，将页完整写回。如果页剩余空间不够，则分裂后写入。

分裂 or 合并。级联分裂和合并。

一个记录大于一个 page 怎么办？ 树的节点是逻辑概念，page or block 是物理概念。一个逻辑节点可以对应多个物理 page。

让 B 树更可靠
B 树不像 LSM-Tree，会在原地修改数据文件。

在树结构调整时，可能会级联修改很多 Page。比如叶子节点分裂后，就需要写入两个新的叶子节点，和一个父节点（更新叶子指针）。

增加预写日志（WAL），将所有修改操作记录下来，预防宕机时中断树结构调整而产生的混乱现场。
使用 latch 对树结构进行并发控制


B 树的优化
B 树出来了这么久，因此有很多优化：

不使用 WAL，而在写入时利用 Copy On Write 技术。同时，也方便了并发控制。如 LMDB、BoltDB。
对中间节点的 Key 做压缩，保留足够的路由信息即可。以此，可以节省空间，增大分支因子。
为了优化范围查询，有的 B 族树将叶子节点存储时物理连续。但当数据不断插入时，维护此有序性的代价非常大。
为叶子节点增加兄弟指针，以避免顺序遍历时的回溯。即 B+ 树的做法，但远不局限于 B+ 树。
B 树的变种，分形树，从 LSM-tree 借鉴了一些思想以优化 seek。


<img width="1778" height="1154" alt="image" src="https://github.com/user-attachments/assets/b6e1399f-a856-4fcf-8abe-0c0debb32bad" />

次级索引（secondary indexes）。即，非主键的其他属性到该元素（SQL 中的行，MongoDB 中的文档和图数据库中的点和边）的映射。


聚集索引和非聚集索引（cluster indexes and non-cluster indexes）
对于存储数据和组织索引，我们可以有多种选择：

数据本身无序的存在文件中，称为 堆文件（heap file），索引的值指向对应数据在 heap file 中的位置。这样可以避免多个索引时的数据拷贝。
数据本身按某个字段有序存储，该字段通常是主键。则称基于此字段的索引为聚集索引（clustered index），从另外一个角度理解，即将索引和数据存在一块。则基于其他字段的索引为非聚集索引，在索引中仅存数据的引用。
一部分列内嵌到索引中存储，一部分列数据额外存储。称为覆盖索引（covering index）   或  包含列的索引（index with included columns）。
索引可以加快查询速度，但需要占用额外空间，并且牺牲了部分更新开销，且需要维持某种一致性。


多列索引（Multi-column indexes）
现实生活中，多个字段联合查询更为常见。比如查询某个用户周边一定范围内的商户，需要经度和纬度二维查询。

可以：

将二维编码为一维，然后按普通索引存储。
使用特殊数据结构，如 R 树。

全文索引和模糊索引（Full-text search and fuzzy indexes）
前述索引只提供全字段的精确匹配，而不提供类似搜索引擎的功能。比如，按字符串中包含的单词查询，针对笔误的单词查询。

在工程中常用 Apace Lucene 库，和其包装出来的服务：Elasticsearch。他也使用类似 LSM-tree 的日志存储结构，但使用其索引进行模糊匹配的过程，本质上是一个有限状态自动机，在行为上类似 Trie 树。


全内存数据结构
随着单位内存成本下降，甚至支持持久化（non-volatile memory，NVM，如 Intel 的 傲腾），全内存数据库也逐渐开始流行。

根据是否需要持久化，内存数据大概可以分为两类：

不需要持久化。如只用于缓存的 Memcached。
需要持久化。通过 WAL、定期 snapshot、远程备份等等来对数据进行持久化。但使用内存处理全部读写，因此仍是内存数据库。
VoltDB, MemSQL, and Oracle TimesTen 是提供关系模型的内存数据库。RAMCloud 是提供持久化保证的 KV 数据库。Redis and Couchbase 仅提供弱持久化保证。

内存数据库存在优势的原因不仅在于不需要读取磁盘，而在更于不需要对数据结构进行序列化、编码后以适应磁盘所带来的额外开销。

当然，内存数据库还有以下优点：

提供更丰富的数据抽象。如 set 和 queue 这种只存在于内存中的数据抽象。
实现相对简单。因为所有数据都在内存中。
此外，内存数据库还可以通过类似操作系统 swap 的方式，提供比物理机内存更大的存储空间，但由于其有更多数据库相关信息，可以将换入换出的粒度做的更细、性能做的更好。

基于非易失性存储器（non-volatile memory，NVM）的存储引擎也是这些年研究的一个热点。



事务型还是分析型



数据仓库
对于一个企业来说，一般都会有很多偏交易型的系统，如用户网站、收银系统、仓库管理、供应链管理、员工管理等等。通常要求高可用与低延迟，因此直接在原库进行业务分析，会极大影响正常负载。因此需要一种手段将数据从原库导入到专门的数仓。

我们称之为 ETL：extract-transform-load。


AP 建模：星状型和雪花型
AP 中的处理模型相对较少，比较常用的有星状模型，也称为维度模型。


如上图所示，星状模型通常包含一张事件表（fact table） 和多张维度表（dimension tables）。事件表以事件流的方式将数据组织起来，然后通过外键指向不同的维度。

星状模型的一个变种是雪花模型，可以类比雪花（❄️）图案，其特点是在维度表中会进一步进行二次细分，讲一个维度分解为几个子维度。比如品牌和产品类别可能有单独的表格。星状模型更简单，雪花模型更精细，具体应用中会做不同取舍。

在典型的数仓中，事件表可能会非常宽，即有很多的列：一百到数百列。

列压缩
将所有数据分列存储在一块，带来了一个意外的好处，由于同一属性的数据相似度高，因此更易压缩。

如果每一列中值阈相比行数要小的多，可以用位图编码（bitmap encoding）。举个例子，零售商可能有数十亿的销售交易，但只有 100,000 个不同的产品。



列族
书中特别提到列族（column families）。它是 Cassandra 和 HBase 中的的概念，他们都起源于自谷歌的 BigTable 。注意到他们和列式（column-oriented）存储有相似之处，但绝不完全相同：

同一个列族中多个列是一块存储的，并且内嵌行键（row key）。
并且列不压缩（存疑？）
因此 BigTable 在用的时候主要还是面向行的，可以理解为每一个列族都是一个子表。


