解释下: 
 - 秒杀场景 一般的解决方法和链路




 - 限流算法





 - 负载均衡算法







什么是云原生  serverless sidecar 微服务 fass？ 

- 【云原生的技术本质】
我的理解：云原生是一种设计哲学
核心思想：为云而生，而不是迁移到云

# 传统应用 vs 云原生应用
   传统应用: 单体 -> 容器化 -> 部署到云
   云原生应用: 从设计之初就考虑分布式、弹性、可观测

云原生本质上是用  分布式系统的思维来构建应用，让应用天然具备云环境的特性：弹性、可靠、可观测。它不仅仅是技术选型，更是一种架构哲学。



- 【微服务 - 业务拆分的艺术】 
 核心思想：按业务边界拆分单体应用
微服务的价值：
  独立部署 - 用户服务更新不影响订单服务
  技术栈自由 - 用户服务用Java，支付服务用Go
  团队自治 - 每个团队负责自己的服务
  挑战：分布式事务问题


- 【Sidecar - 服务网格的基石】
核心思想：将非业务逻辑抽离到独立进程
Sidecar负责什么：
# 业务容器专注业务逻辑
# Sidecar处理基础设施关注点
 - 服务发现
 - 负载均衡  
 - 熔断限流
 - 安全认证
 - 可观测性

 -【Serverless - 函数即服务】
核心思想：只关心代码，不关心服务器
// 不需要考虑：服务器、容器、扩缩容、运维
Serverless的价值：
按需付费 - 只为实际执行时间付费
自动扩缩容 - 0到无穷大的弹性
运维成本为零 - 专注业务逻辑

适用场景：
# 事件驱动场景
- 文件上传处理
- 定时任务
- API网关
- 数据处理管道

# 不适用场景  
- 长连接服务
- 有状态应用
- 复杂的依赖关系


演进路径：
微服务 - 解决单体应用的问题
Sidecar - 解决微服务的复杂性问题
Serverless - 解决基础设施的问题
技术选型建议：
   小团队/简单业务 → Serverless
   中等复杂度 → 微服务
   大规模分布式 → 微服务 + Sidecar



