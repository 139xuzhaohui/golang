- 数据库的学习！！加油 赶紧搞哦 -- 分库分表，那对于连表的 你咋搞呢
- redis redis的锁， 如果是ap的话--怎么看数据一致性呢？ 尤其是锁！

- 对于系统你还有什么想改进的吗？？

对于消息会不会跌丢失， 我们可以先拆分 消息的一个流程

生产者  -- ACK 保证

中间者-暂存  【这里的话 就要看咯】 

消费者。-- ACK 依赖 消费位点（由消费者自己主动提交）




【过期策略】

不过期
LRU
啥的
数据结构什么的！ 



【持久化】


redis的丢数据的case
AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能 -- 异步的？？写盘是的， 但是写缓冲区不是的！

主从复制也是异步的，
【AOF】 是主线程去完成的噢 --先写命令 再记日志

aof 是先写到缓冲区的，依赖三个模式 去刷盘 【缓冲区一出来】就应该考虑下他的大小，写满了怎么办？ 【AOF重写机制】 --mysql 好像是环形写入，
三种模式去 写回硬盘 
always -- 总是/每次都
everysec --  每秒
no -- byOS 由操作系统决定

AOF 日志记录的是操作命令，不是实际的数据

【AOF重写 --可以理解成 整理并压缩】（有点像gc，）bgrewriteaof 后台线程哈，  --为啥要提到它， 因为它也用到了Copy on write， 好的 牛掰 写时复制，
【纠正纠正， cow consurrenthashmap 没有用哈！！！， 用到的是 copyonwirteList 啥的】   ConcurrentHashMap ! 记起来了吗？---【这是错误的❌】

还有WAL （write ahead log）

写时复制，-- 说实话我不是很明白- 为啥是有物流地址变化的时候才会触发？ 嗯? 不应该都是复制一份吗？
 - 写有锁， 但是读没有锁， 支持【并发的读，并且是读已提交的场景 不会存在 size 已经加一， 但是get值get不到！】--
 - 线程安全 -- 应该说相对安全，大家瞬时的状态都是 稳定的  且是 一致的


当然，AOF 持久化能也是有风险。
1、第一个风险，
执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服
务器发生宕机了，这个数据就会有丢失的风险。

2、第二个风险，前面说道，由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令
的的执行，但是可能会给「下一个」命令带来阻塞风险。 ---主线程
因为将命令写入到日志的这个操作也是在主进程完成的（执行命令也是在主进程），也就是说这两个操作
是同步的。



【RDB】是默认开启的， 但是默认配置不知道
配置维度 XX时间内内，至少有XXX次写操作 执行触发 BGSAVE
他是异步的哈， 全部强制刷盘的话 就是bgsave

RDB -- 是异步的哈！！！  不不不 他有两个命令， save（同步） 和 bgsave （异步）！ 两个命令
RDB的话 会比较的慢 因为都是全量的一次存储
在 执行bgsave的过程中， 也是可以读写的， 因为有COW噢 --- 好像也不太对
这个可以 留个🤔️ 疑问 cow 带来的是？ 

而且 日常中我们redis 的 持久化的策略是什么？？？


日常建议：

对于大数据量的KV操作Redis做了一些优化和限制来避免线程阻塞，
但是实际场景中尽量避免大KV场景，
单次请求命令控制在16K以内， --- 16kb
响应控制在64K以内比较友好。 --- 64kb
持久化策略尽量选择AOF_FSYNC_EVERYSEC，因为官方说AOF_FSYNC_ALWAYS虽然能保证一致性，但是巨慢：




其次 到了后面 持久化的方式就变成了混合持久化









