
try to Qwen ---a little bad


# NoSQL 和 NewSQL 数据库学习指南 

分布式数据库：
#### Apache Cassandra   AP或者CP 最终一致性
Apache Cassandra (Cassandra) 是一种开源 **NoSQL** 数据库，专为管理跨多个数据中心的海量数据而构建。 <br>
Cassandra 被设计为分布式数据库管理系统 (DBMS)，依赖于点对点架构。Cassandra 集群中的每个节点或存储部分数据的**单个服务器都是平等的，不依赖于主节点**。 <br>
数据分布在各个对等节点，而非集中存储，从而消除了单点故障（单一故障可能会迅速引发连锁反应）。通过这种设计，系统即使在计划内停机或突发变化期间，也能实现无缝复制、高效数据分发并保持持续服务。 <br>
Cassandra 通过 **可调的一致性** 级别解决了这种权衡，允许用户根据用例优先考虑可用性或一致性 <br>
- Cassandra 的存储引擎采用由 **提交日志**、**内存表（memtable）** 和 **排序字符串表（SSTable）** 文件组成的分步流程（或写入路径）。
- 该流程快速接受写入操作并予以保护。频繁访问的数据保存在缓存中以供**低延迟查询** ，而**压缩（一种自动管理功能）** 有助于确保高效的长期数据存储
 │      6 - **特点**：高可用性、无单点故障、线性扩展                                                  <br>
 │      7 - **使用场景**：时间序列数据、物联网应用、用户活动跟踪                                       <br>
 │      8 - **数据模型**：宽列存储，基于行键的访问                                                     <br>
 │      9 - **一致性模型**：最终一致性，可配置一致性级别                                               <br>
 │     10 - **CQL**（Cassandra查询语言）语法类似SQL但有差异 


#### Google Spanner（全球强一致性） paxos
 │      6 - **特点**： 
 │      6 - **TrueTime API：** 使用原子钟和GPS实现全球时间同步  <br>
 │      6 - **外部一致性：** 比传统ACID更强的一致性保证
 │      6 - **自动分片：** 根据负载自动分割和迁移数据
- TrueTime API 是一个非常有创意的东西，可以同步全球的时间。上表就是TrueTime API。TT.now()可以获得一个绝对时间TTinterval，这个值和UnixTime是相同的，同时还能够得到一个误差e。TT.after(t)和TT.before(t)是基于TT.now()实现的。
- 那这个TrueTime API实现靠的是GFS和原子钟。之所以要用两种技术来处理，是因为导致这两个技术的失败的原因是不同的。GPS会有一个天线，电波干扰会导致其失灵。原子钟很稳定。当GPS失灵的时候，原子钟仍然能保证在相当长的时间内，不会出现偏差。
<br>

#### MongoDB 和 Elasticsearch （nosql 文档型DB）
- 感觉es 都不算是数据库--更像是for search的，mongodb的话--like文档记录
- 核心区别：
- MongoDB：事务支持、复杂关系、实时写入 
 │     13 - **特点**：文档存储、自动分片、跨区域复制  <br>
 │     15 - **数据模型**：JSON/BSON文档  <br>                                                             
 │     16 - **查询能力**：丰富的查询操作符，支持文本搜索、地理空间查询
 <br>      
- Elasticsearch：全文搜索、实时分析、只读优化 **倒排索引**                                                                     
 │     43 - **特点**：全文搜索、实时分析、分布式架构  <br>                                                            
 │     44 - **使用场景**：日志分析、网站搜索、商业智能    <br>                                                         
 │     45 - **数据模型**：JSON文档          <br>                                                                      
 │     46 - **核心技术**：基于Apache Lucene，倒排索引  
<br>

#### LevelDB（Google开源，C++）
 │      6 - **特点**： <br>
 │      6 - **LSM-Tree结构：** 写入友好，顺序写入性能极高  <br>
 │      6 - **压缩合并：** 后台自动压缩，节省存储空间 <br>
 │      6 - 单机存储：不支持分布式，但可作为分布式系统的存储层
<br>

#### RocksDB（Facebook基于LevelDB优化，C++）
 │      6 - **特点**： <br>
 │      6 - **性能优化：** 多线程压缩、更好的缓存策略  <br>
 │      6 - **功能增强：** 列族、事务、备份恢复   <br>
 │      6 - 生产就绪：更适合大规模生产环境  
<br>

#### InfluxDB（时序数据库，Go语言）
 │      6 - **特点**： <br>
 │      6 - 时间索引：按时间分片存储，查询效率高  <br>
 │      6 - 数据压缩：针对时序数据的压缩算法   <br>
 │      6 - TTL支持：自动删除过期数据   
<br>

#### Neo4j (图数据库)                                                                             
 │     26 - **特点**：原生图存储，ACID事务，强大的Cypher查询语言                                    <br>
 │     27 - **使用场景**：社交网络、推荐引擎、欺诈检测、知识图谱                                    <br>
 │     28 - **数据模型**：节点、关系、属性                                                     <br>
 │     29 - **查询语言**：Cypher，专为图遍历设计                                               <br>

####   ClickHouse                                                                             
 │     71 - **特点**：开源列式数据库、极快的分析查询、高吞吐量                                         <br>
 │     72 - **使用场景**：实时分析、OLAP工作负载                                                       <br>
 │     73 - **性能**：在聚合查询上表现卓越  

- 缓存数据库 
#### Redis vs Memcached：
 │      6 - **特点**：   <br>
 │      6 - 数据结构：Redis支持复杂数据类型，Memcached只支持字符串  <br>
 │      6 - **持久化：** Redis支持RDB/AOF，Memcached纯内存   <br>
 │      6 - 功能：Redis支持发布订阅、Lua脚本等   <br>

# 存储引擎

#### B+Tree 存储引擎 

#### LSM-Tree 存储引擎 及其压缩策略

- RocksDB/LevelDB 核心结构
  
  、、、
  private:
    MemTable* active_memtable;      // 活跃内存表
    vector<MemTable*> immutable_memtables;  // 不可变内存表
    vector<Level> levels;           // 多层SST文件
 、、、

、、、
public:
    void Put(const string& key, const string& value) {
        // 1. 写WAL日志
        wal->Append(key, value);
        
        // 2. 写入MemTable
        active_memtable->Put(key, value);
        
        // 3. 检查是否需要刷盘
        if (active_memtable->Size() > threshold) {
            TriggerFlush();
        }
    }
    
    string Get(const string& key) {
        // 1. 查找MemTable
        string value;
        if (active_memtable->Get(key, &value)) {
            return value;
        }
        
        // 2. 查找Immutable MemTables
        for (auto& imm : immutable_memtables) {
            if (imm->Get(key, &value)) {
                return value;
            }
        }
        
        // 3. 从新到旧查找SST文件
        for (int level = 0; level < levels.size(); level++) {
            if (levels[level].Get(key, &value)) {
                return value;
            }
        }
        
        return ""; // Not found
    }

、、、

- **LSM-Tree 压缩策略：**
-  Size-Tiered Compaction (RocksDB默认)

#### Hash 存储引擎

新兴存储模型
####  Learned Index (学习索引)
####  Persistent Memory 存储引擎
- 直接写入持久内存，无需传统的写盘操作 【fsyc --不是很懂不就是写磁盘吗？ 写持久化内存和磁盘是？】
- HashEntry* entry = findOrCreateEntry(key);
#### GPU加速存储引擎
- CUDA加速的并行查找

#### 混合存储引擎
- MongoDB
、、、
// 结合B+Tree和LSM-Tree优势
class WiredTigerEngine {
private:
    LSMTree lsm_tree;      // 处理写入密集负载
    BPlusTree btree;       // 处理读取密集负载
、、、


  #### TiKV (分布式存储引擎)
、 │     73 - **性能**：在聚合查询上表现卓越  


- 缓存数据库 
#### Redis vs Memcached：
 │      6 - **特点**：   <br>
 │      6 - 数据结构：Redis支持复杂数据类型，Memcached只支持字符串  <br>
 │      6 - **持久化：** Redis支持RDB/AOF，Memcached纯内存   <br>
 │      6 - 功能：Redis支持发布订阅、Lua脚本等   <br>


# 存储引擎


#### B+Tree 存储引擎 


#### LSM-Tree 存储引擎 及其压缩策略


- RocksDB/LevelDB 核心结构
  
、、、
  private:
    MemTable* active_memtable;      // 活跃内存表
    vector<MemTable*> immutable_memtables;  // 不可变内存表
    vector<Level> levels;           // 多层SST文件
、、、


、、、
public:
    void Put(const string& key, const string& value) {
        // 1. 写WAL日志
        wal->Append(key, value);
        
        // 2. 写入MemTable
        active_memtable->Put(key, value);
        
        // 3. 检查是否需要刷盘
        if (active_memtable->Size() > threshold) {
            TriggerFlush();
        }
    }
    
    string Get(const string& key) {
        // 1. 查找MemTable
        string value;
        if (active_memtable->Get(key, &value)) {
            return value;
        }
        
        // 2. 查找Immutable MemTables
        for (auto& imm : immutable_memtables) {
            if (imm->Get(key, &value)) {
                return value;
            }
        }
        
        // 3. 从新到旧查找SST文件
        for (int level = 0; level < levels.size(); level++) {
            if (levels[level].Get(key, &value)) {
                return value;
            }
        }
        
        return ""; // Not found
    }

、、、


- **LSM-Tree 压缩策略：**
-  Size-Tiered Compaction (RocksDB默认)


#### Hash 存储引擎


新兴存储模型
####  Learned Index (学习索引)
####  Persistent Memory 存储引擎
- 直接写入持久内存，无需传统的写盘操作 【fsyc --不是很懂不就是写磁盘吗？ 写持久化内存和磁盘是？】
- HashEntry* entry = findOrCreateEntry(key);
#### GPU加速存储引擎
- CUDA加速的并行查找


#### 混合存储引擎
- MongoDB
、、、
// 结合B+Tree和LSM-Tree优势
class WiredTigerEngine {
private:
    LSMTree lsm_tree;      // 处理写入密集负载
    BPlusTree btree;       // 处理读取密集负载
、、、


  #### TiKV (分布式存储引擎)
、、、
/ 基于RocksDB，增加分布式特性
pub struct TiKVEngine {
    rocksdb: RocksDB,
    raft: RaftEngine,      // 分布式一致性
    region_manager: RegionManager,  // 数据分片管理
}
、、、

### 总结
写入密集型应用

推荐：LSM-Tree (RocksDB, LevelDB)
场景：日志系统、时序数据、IoT数据收集
原因：顺序写入性能优异，写放大可控
读取密集型应用

推荐：B+Tree (InnoDB, WiredTiger)
场景：OLTP系统、用户查询、报表系统
原因：点查询和范围查询性能优秀       

