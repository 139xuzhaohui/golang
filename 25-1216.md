
try to Qwen ---a little bad

# from ddia
1. Oracle 的 PGQL：
2. 逗号连接的多个**谓词** 表达式为且的关系。 什么是谓词??? 【谓词是一个可以独立判断真假的表达式】 -- 返回布尔值。
3. 声明式 (declarative) vs 命令式 (imperative)：
> 数据模型：如何组织数据，如何标准化关系，如何关联现实。它既决定了我们构建软件的方式（实现），也左右了我们看待问题的角度（认知）。
<img width="500" height="400" alt="image" src="https://github.com/user-attachments/assets/1337aca7-0c78-4b75-9f38-7ddb427984ed" />

> - 作为应用开发者， 你将现实中的具体问题抽象为一组对象、**数据结构（data structure）** 以及作用于其上的 API。
> - 作为数据库管理员（DBA），为了持久化上述数据结构，你需要将他们表达为通用的 **数据模型（data model）** ，如文档数据库中的 XML/JSON、关系数据库中的表、图数据库中的图。 
> - 作为数据库系统开发者，你需要将上述数据模型组织为内存中、硬盘中或者网络中的**字节（Bytes） 流**，并提供多种操作数据集合的方法。
> - 作为硬件工程师，你需要将字节流表示为二极管的电位（内存）、磁场中的磁极（磁盘）、**光纤中的光信号（网络）**。

### 存储和查询
查询类型主要分为两大类：
**OLTP: 交易、火车票 || OLAP: 报表、查询**
> OLTP 又会分为两大类
1. log-structured 流, **只允许追加，所有修改都表现为文件的追加和文件整体增删** for 好处的话就是：**就写入很快呀--总是顺序写～** ，
   - 如: Bitcask、LevelDB、RocksDB、Cassandra、Lucene
2. update-in-place 流, **以页（page）为粒度对磁盘数据进行修改, 就是本地更新** for 好处的话就是：**面向页、查找树，一次加载的多** ，
   - 如: B 族树，所有主流关系型数据库和一些非关系型数据库
> **至于列式存储**
- 对于数据仓库，本章分析了它与 OLTP 的主要不同之处。
- **数据仓库主要侧重于聚合查询，需要扫描很大量的数据**，此时，索引就相对不太有用。需要考虑的是存储成本、带宽优化等，由此引出*列式存储*。

> 本节由一个 shell 脚本出发，到一个相当简单但可用的存储引擎 **Bitcask**，然后引出 **LSM-tree**，他们都属于**日志流范畴**。之后转向存储引擎另一流派——**B 族树**，之后对其做了简单对比。最后探讨了存储中离不开的结构——**索引**
> 这便是数据库存储引擎设计和选择时最常见的**权衡（trade off）**： 读和写
- 恰当的存储格式能加快写（日志结构），但是会让读取很慢；也可以加快读（查找树、B 族树），但会让写入较慢。
- 为了弥补读性能，可以构建索引。**但是会牺牲写入性能和耗费额外空间**。 
- 存储格式一般不好动，但是索引构建与否，一般交予用户选择。
 
 #### 哈希索引
写：文件追加写。 <br>
读：一次内存查询，一次磁盘 seek；如果数据已经被缓存，则 seek 也可以省掉。<br>
如果你的 key 集合很小（意味着能全放内存），但是每个 key 更新很频繁，那么 Bitcask 便是你的菜。举个栗子：频繁更新的视频播放量，key 是视频 url，value 是视频播放量。
> 但有个很重要问题，单个文件越来越大，磁盘空间不够怎么办？
> 在文件到达一定尺寸后，就新建一个文件，将原文件变为只读。同时为了回收多个 key 多次写入的造成的空间浪费，可以将只读文件进行紧缩（compact），将旧文件进行重写，挤出“水分”（被覆写的数据）以进行垃圾回收。
<br>

但日志结构有几个 **原地更新结构** 无法做的 **优点**：
1. **以顺序写代替随机写**。对于磁盘和 SSD，顺序写都要比随机写快几个数量级。
2. **简易的并发控制**。由于大部分的文件都是不可变（immutable） 的，因此更容易做并发读取和紧缩。也不用担心原地更新会造成新老数据交替。
3. **更少的内部碎片**。每次紧缩会将垃圾完全挤出。*但是原地更新就会在 page 中留下一些不可用空间。 --why????*
<br>
- 劣势
1. 所有 Key 必须放内存。一旦 Key 的数据量超过内存大小，这种方案便不再 work。当然你可以设计基于磁盘的哈希表，但那又会带来大量的随机写。
2. **不支持范围查询**。由于 key 是无序的，要进行范围查询必须全表扫描。

> 这里就很像你自己 写代码时候 数据结构的存储 多级map 和一级map,虽然都是On,但是多级他的内存就要大一些

进行优化
#### SSTable && LSM-Trees
让这些文件按 key 有序。我们称这种格式为：SSTable（Sorted String Table）。 <br>
这种文件格式有什么优点呢？ -- 高效的数据文件合并。即有序文件的归并外排，顺序读，顺序写。  *归并的复杂度是???* <br>
不需要在内存中保存所有数据的索引。仅需要记录下每个文件界限（以区间表示：[startKey, endKey]，当然实际会记录的更细）即可。查找某个 Key 时，去所有包含该 Key 的区间对应的文件二分查找即可  <br>
1. 分块压缩，节省空间，减少 IO** 
2. 相邻 Key 共享前缀，既然每次都要批量取，那正好一组 key batch 到一块，称为 block，且只记录 block 的索引。 
SSTables 格式听起来很美好，但须知数据是乱序的来的，**我们如何得到有序的数据文件呢**？
> 可以拆解为两个小问题：
> 1. 如何构建。??? 构建有序
> 2. 如何维护。??? 如何处理这些文件 <br>
> 构建 SSTable 文件。将乱序数据在外存（磁盘 or SSD）中上整理为有序文件，是比较难的。但是在内存就方便的多。**于是一个大胆的想法就形成了**：
> 在内存中维护一个**有序结构（称为 MemTable）。红黑树、AVL 树、跳表**。 到达一定阈值之后全量 **dump 到外存**。
> 维护 SSTable 文件。为什么需要维护呢？首先要问，对于上述复合结构，我们怎么进行查询：
> 1. 先去 MemTable 中查找，如果命中则返回。
> 2. 再去 SSTable 按时间顺序由新到旧逐一查找。
> 3. 如果 SSTable 文件越来越多，则查找代价会越来越大。因此需要将多个 SSTable 文件合并，以减少文件数量，同时进行 GC，我们称之为**紧缩（ Compaction）**。

- 该方案的问题：如果出现宕机，内存中的数据结构将会消失。解决方法也很经典：**WAL**。
- **WAL 是为了什么** 大声告诉 我
- is for 防丢失（如果出现宕机，内存中的数据结构将会消失）

####  从 SSTables 到 LSM-Tree
将前面几节的一些碎片有机的组织起来，便是时下流行的存储引擎 LevelDB 和 RocksDB 后面的存储结构：LSM-Tree：<br>

Elasticsearch 和 Solr 的索引引擎 Lucene，也使用类似 LSM-Tree 存储结构。但其数据模型不是 KV，但类似：word → document list。<br>









# NoSQL 和 NewSQL 数据库学习指南 

分布式数据库：
#### Apache Cassandra   AP或者CP 最终一致性
Apache Cassandra (Cassandra) 是一种开源 **NoSQL** 数据库，专为管理跨多个数据中心的海量数据而构建。 <br>
Cassandra 被设计为分布式数据库管理系统 (DBMS)，依赖于点对点架构。Cassandra 集群中的每个节点或存储部分数据的**单个服务器都是平等的，不依赖于主节点**。 <br>
数据分布在各个对等节点，而非集中存储，从而消除了单点故障（单一故障可能会迅速引发连锁反应）。通过这种设计，系统即使在计划内停机或突发变化期间，也能实现无缝复制、高效数据分发并保持持续服务。 <br>
Cassandra 通过 **可调的一致性** 级别解决了这种权衡，允许用户根据用例优先考虑可用性或一致性 <br>
- Cassandra 的存储引擎采用由 **提交日志**、**内存表（memtable）** 和 **排序字符串表（SSTable）** 文件组成的分步流程（或写入路径）。
- 该流程快速接受写入操作并予以保护。频繁访问的数据保存在缓存中以供**低延迟查询** ，而**压缩（一种自动管理功能）** 有助于确保高效的长期数据存储
 │      6 - **特点**：高可用性、无单点故障、线性扩展                                                  <br>
 │      7 - **使用场景**：时间序列数据、物联网应用、用户活动跟踪                                       <br>
 │      8 - **数据模型**：宽列存储，基于行键的访问                                                     <br>
 │      9 - **一致性模型**：最终一致性，可配置一致性级别                                               <br>
 │     10 - **CQL**（Cassandra查询语言）语法类似SQL但有差异 


#### Google Spanner（全球强一致性） paxos
 │      6 - **特点**： 
 │      6 - **TrueTime API：** 使用原子钟和GPS实现全球时间同步  <br>
 │      6 - **外部一致性：** 比传统ACID更强的一致性保证
 │      6 - **自动分片：** 根据负载自动分割和迁移数据
- TrueTime API 是一个非常有创意的东西，可以同步全球的时间。上表就是TrueTime API。TT.now()可以获得一个绝对时间TTinterval，这个值和UnixTime是相同的，同时还能够得到一个误差e。TT.after(t)和TT.before(t)是基于TT.now()实现的。
- 那这个TrueTime API实现靠的是GFS和原子钟。之所以要用两种技术来处理，是因为导致这两个技术的失败的原因是不同的。GPS会有一个天线，电波干扰会导致其失灵。原子钟很稳定。当GPS失灵的时候，原子钟仍然能保证在相当长的时间内，不会出现偏差。
<br>

#### MongoDB 和 Elasticsearch （nosql 文档型DB）
- 感觉es 都不算是数据库--更像是for search的，mongodb的话--like文档记录
- 核心区别：
- MongoDB：事务支持、复杂关系、实时写入 
 │     13 - **特点**：文档存储、自动分片、跨区域复制  <br>
 │     15 - **数据模型**：JSON/BSON文档  <br>                                                             
 │     16 - **查询能力**：丰富的查询操作符，支持文本搜索、地理空间查询
 <br>      
- Elasticsearch：全文搜索、实时分析、只读优化 **倒排索引**                                                                     
 │     43 - **特点**：全文搜索、实时分析、分布式架构  <br>                                                            
 │     44 - **使用场景**：日志分析、网站搜索、商业智能    <br>                                                         
 │     45 - **数据模型**：JSON文档          <br>                                                                      
 │     46 - **核心技术**：基于Apache Lucene，倒排索引  
<br>

#### LevelDB（Google开源，C++）
 │      6 - **特点**： <br>
 │      6 - **LSM-Tree结构：** 写入友好，顺序写入性能极高  <br>
 │      6 - **压缩合并：** 后台自动压缩，节省存储空间 <br>
 │      6 - 单机存储：不支持分布式，但可作为分布式系统的存储层
<br>

#### RocksDB（Facebook基于LevelDB优化，C++）
 │      6 - **特点**： <br>
 │      6 - **性能优化：** 多线程压缩、更好的缓存策略  <br>
 │      6 - **功能增强：** 列族、事务、备份恢复   <br>
 │      6 - 生产就绪：更适合大规模生产环境  
<br>

#### InfluxDB（时序数据库，Go语言）
 │      6 - **特点**： <br>
 │      6 - 时间索引：按时间分片存储，查询效率高  <br>
 │      6 - 数据压缩：针对时序数据的压缩算法   <br>
 │      6 - TTL支持：自动删除过期数据   
<br>

#### Neo4j (图数据库)                                                                             
 │     26 - **特点**：原生图存储，ACID事务，强大的Cypher查询语言                                    <br>
 │     27 - **使用场景**：社交网络、推荐引擎、欺诈检测、知识图谱                                    <br>
 │     28 - **数据模型**：节点、关系、属性                                                     <br>
 │     29 - **查询语言**：Cypher，专为图遍历设计                                               <br>

####   ClickHouse                                                                             
 │     71 - **特点**：开源列式数据库、极快的分析查询、高吞吐量                                         <br>
 │     72 - **使用场景**：实时分析、OLAP工作负载                                                       <br>
 │     73 - **性能**：在聚合查询上表现卓越  

- 缓存数据库 
#### Redis vs Memcached：
 │      6 - **特点**：   <br>
 │      6 - 数据结构：Redis支持复杂数据类型，Memcached只支持字符串  <br>
 │      6 - **持久化：** Redis支持RDB/AOF，Memcached纯内存   <br>
 │      6 - 功能：Redis支持发布订阅、Lua脚本等   <br>

# 存储引擎

#### B+Tree 存储引擎 

#### LSM-Tree 存储引擎 及其压缩策略

- RocksDB/LevelDB 核心结构
  
  、、、
  private:
    MemTable* active_memtable;      // 活跃内存表
    vector<MemTable*> immutable_memtables;  // 不可变内存表
    vector<Level> levels;           // 多层SST文件
 、、、

、、、
public:
    void Put(const string& key, const string& value) {
        // 1. 写WAL日志
        wal->Append(key, value);
        
        // 2. 写入MemTable
        active_memtable->Put(key, value);
        
        // 3. 检查是否需要刷盘
        if (active_memtable->Size() > threshold) {
            TriggerFlush();
        }
    }
    
    string Get(const string& key) {
        // 1. 查找MemTable
        string value;
        if (active_memtable->Get(key, &value)) {
            return value;
        }
        
        // 2. 查找Immutable MemTables
        for (auto& imm : immutable_memtables) {
            if (imm->Get(key, &value)) {
                return value;
            }
        }
        
        // 3. 从新到旧查找SST文件
        for (int level = 0; level < levels.size(); level++) {
            if (levels[level].Get(key, &value)) {
                return value;
            }
        }
        
        return ""; // Not found
    }

、、、

- **LSM-Tree 压缩策略：**
-  Size-Tiered Compaction (RocksDB默认)

#### Hash 存储引擎

新兴存储模型
####  Learned Index (学习索引)
####  Persistent Memory 存储引擎
- 直接写入持久内存，无需传统的写盘操作 【fsyc --不是很懂不就是写磁盘吗？ 写持久化内存和磁盘是？】
- HashEntry* entry = findOrCreateEntry(key);
#### GPU加速存储引擎
- CUDA加速的并行查找

#### 混合存储引擎
- MongoDB
、、、
// 结合B+Tree和LSM-Tree优势
class WiredTigerEngine {
private:
    LSMTree lsm_tree;      // 处理写入密集负载
    BPlusTree btree;       // 处理读取密集负载
、、、


  #### TiKV (分布式存储引擎)
、 │     73 - **性能**：在聚合查询上表现卓越  


- 缓存数据库 
#### Redis vs Memcached：
 │      6 - **特点**：   <br>
 │      6 - 数据结构：Redis支持复杂数据类型，Memcached只支持字符串  <br>
 │      6 - **持久化：** Redis支持RDB/AOF，Memcached纯内存   <br>
 │      6 - 功能：Redis支持发布订阅、Lua脚本等   <br>


# 存储引擎


#### B+Tree 存储引擎 


#### LSM-Tree 存储引擎 及其压缩策略


- RocksDB/LevelDB 核心结构
  
、、、
  private:
    MemTable* active_memtable;      // 活跃内存表
    vector<MemTable*> immutable_memtables;  // 不可变内存表
    vector<Level> levels;           // 多层SST文件
、、、


、、、
public:
    void Put(const string& key, const string& value) {
        // 1. 写WAL日志
        wal->Append(key, value);
        
        // 2. 写入MemTable
        active_memtable->Put(key, value);
        
        // 3. 检查是否需要刷盘
        if (active_memtable->Size() > threshold) {
            TriggerFlush();
        }
    }
    
    string Get(const string& key) {
        // 1. 查找MemTable
        string value;
        if (active_memtable->Get(key, &value)) {
            return value;
        }
        
        // 2. 查找Immutable MemTables
        for (auto& imm : immutable_memtables) {
            if (imm->Get(key, &value)) {
                return value;
            }
        }
        
        // 3. 从新到旧查找SST文件
        for (int level = 0; level < levels.size(); level++) {
            if (levels[level].Get(key, &value)) {
                return value;
            }
        }
        
        return ""; // Not found
    }

、、、


- **LSM-Tree 压缩策略：**
-  Size-Tiered Compaction (RocksDB默认)


#### Hash 存储引擎


新兴存储模型
####  Learned Index (学习索引)
####  Persistent Memory 存储引擎
- 直接写入持久内存，无需传统的写盘操作 【fsyc --不是很懂不就是写磁盘吗？ 写持久化内存和磁盘是？】
- HashEntry* entry = findOrCreateEntry(key);
#### GPU加速存储引擎
- CUDA加速的并行查找


#### 混合存储引擎
- MongoDB
、、、
// 结合B+Tree和LSM-Tree优势
class WiredTigerEngine {
private:
    LSMTree lsm_tree;      // 处理写入密集负载
    BPlusTree btree;       // 处理读取密集负载
、、、


  #### TiKV (分布式存储引擎)
、、、
/ 基于RocksDB，增加分布式特性
pub struct TiKVEngine {
    rocksdb: RocksDB,
    raft: RaftEngine,      // 分布式一致性
    region_manager: RegionManager,  // 数据分片管理
}
、、、

### 总结
写入密集型应用

推荐：LSM-Tree (RocksDB, LevelDB)
场景：日志系统、时序数据、IoT数据收集
原因：顺序写入性能优异，写放大可控
读取密集型应用

推荐：B+Tree (InnoDB, WiredTiger)
场景：OLTP系统、用户查询、报表系统
原因：点查询和范围查询性能优秀       

