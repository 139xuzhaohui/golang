
事务：
 - 什么是事务
 - 当我们谈到事务的时候，要说些啥
 - 首先 事务的特性？ ACID么？ 好像不是的吧
 - 数据库里的事务 和 （业务系统间的事务） 分布式事务、分布式事务的解决方法、 分布式事务的算法


 什么是事务： 
   是说： 是在数据库或其他存储系统中，为了保证 数据操作的一致性、完整性而进行的一组操作，这组操作要么全部成功，要么全部失败回滚。
   它的核心是 ACID 特性： 
   A 原子性  Atomicity
   C 一致性  Consistency
   I 隔离性  Isolation
   D 持久性  Durability
A :  事务中的操作不可分割，要么全部成功，要么全部失败。 关于转账或者积分兑换操作，在这种 有增有减的case中，得保持一次操作的原子性
C : 事务完成后数据必须符合预定的规则，不破坏数据完整性。 --可以理解成 加减是平衡的，不得多扣多补，也不行 少退少补
I : 事务的隔离性---是发生在多个事务间的，各个事务应该保持隔离，不会互相影响 -- 这个隔离的性质 也会带来事务之间的关系是怎么样的， 比如数据库里的 事务隔离级别
D : 事务一旦提交了， 或者是完成了，应该被永久保存，=== 可以支持恢复，如果系统崩溃了


传统单机事务（JDBC / 本地事务）只能保证单库内一致性，跨服务就不能直接用



【数据库里的事务】
- 事务的隔离级别
 读未提交 --- RU （估计会出现脏读）
 读已提交 -- RC  （估计会出现不可重复读） --解释一下 ？？？？ 【一个事务里对于一个数据重复读,此时，另外一个事务操作了该数据且提交了，那么当前事务就会读到了不同的值; 】
 可重复读 -- RR  （估计会出现幻读） -- 主要是count这种操作
 串性化 -- Serializable
 【我记得公司里一般都是 RC】
 每个隔离级别- 对于事务数据之间的安全性、可见性 越发严格

 数据库的事务隔离级别 怎么实现的， 水平对比一下 postgreSQL oceanBaseSQL mongoSQL ES 这种


 【分布式系统下的事务】
 - 分布式 就不再此过多说明了， 他的一些基础理论可以想想 CAP BASE -- 分别什么含义来着 
 - 分布式事务，是指一个事物的完成/提交 -需要依赖网络中的 不同节点/系统的 上事务的一个执行结果，当然业务节点里也看 是强依赖还是弱依赖， 

 - 分布式事务是指 : 
    事务的参与方分布 在不同的物理节点、系统或服务中，这些节点之间通过网络进行通信，
    一个全局事务的成功或失败 依赖于 多个子事务的执行结果。如果任何一个参与方的事务失败，都可能导致整个业务无法完成。
   
    与单机事务不同，分布式事务不仅要保证数据一致性，还要面对 网络延迟、节点故障、部分成功、数据副本同步延迟 等问题，
    
    因此在实际业务场景中 主要以 会区分 【强一致性（强依赖）】 和 【最终一致性（弱依赖）】 来设计方案 
  
[通用的分布式事务的解决方式]
还是从业务的场景来区分
 1、如果你是 【强一致性（强依赖）】 的， 
那么 
   1.1、 XA 协议 基于2pc 两阶段提交， 
   prepare 和 commit /rollback ； 
   强一致的， 就比需依赖其他节点的接口， --随之带来的就是同步阻塞，性能较差

   1.2  基于TCC的补偿事务， 将事务拆分成3个阶段
    try --预扣减资源，不做最终提交，比如门票、住宿啥的
    confirm -- 确认提交
    cancel -- 释放资源， 
   相比较于XA 稍微灵活一点，半阻塞， 可以通过补偿逻辑来 提高可用性， --- 需要考虑比较多的边界问题， 具体问题具体拆分

2、如果你是 【最终一致性（弱依赖）】 的， 
那么  你可以
 
  1.1、可靠消息 + 异步确认
    MQ + 异步确认
    
  1.2、Saga 模式
   来自长事务（Long-lived Transaction）的分布式事务思想。将一个大事务拆成多个本地事务 T1, T2, ..., Tn。 每个本地事务都有对应的补偿事务 C1, C2, ..., Cn（用于回滚）。
   执行顺序：T1 → T2 → ... → Tn，一旦某个事务失败，就按反序执行补偿事务 Cn → Cn-1 → ... → C1。 --- 这里是不阻塞的， 因为失败了 就发起已经执行的事务 进行回滚
   优点：非阻塞、高性能，适合跨多个服务的长事务。
   缺点：补偿逻辑需要业务自己实现，补偿可能失败，需要更多兜底策略。

2、混合型 / 柔性事务方案（在某些步骤要求强一致，在其他步骤允许最终一致）
那么  你可以
  有的业务链路会在关键步骤使用强一致（例如核心扣款），在非关键部分（例如通知、日志）使用最终一致，常见是强一致 + MQ 补偿组合。
  有的会使用TCC + 消息队列，一部分用 Try/Confirm 保证无误，一部分异步发放。

一般的做法， 如果公司业务规模很大了， 一般会有个 
  所以需要一个「中间件」，帮你管理跨服务跨库的事务，保证最终一致性，同时性能可接受 ！！！

  比如蚂蚁内部 XTS: 
    1、事务的注册、关联、上下文传递
      在一次用户请求发起后，把涉及的多个服务的事务统一关联到一个全局事务 ID。
    2、分布式事务发起、提交、回滚
      协调各个参与者的本地事务，让它们要么全成功，要么全回滚。
    3、支持多种事务模式
    4、故障恢复： -- 如果有服务挂掉或网络异常，事务管理器能根据日志做补偿、恢复。


在支付宝等核心业务里，支付链路通常配合 TCC / Saga，而不是纯 XA，因为吞吐量要求极高。 【XA 模式（两阶段提交）， 可以确保强一致，但适合对性能要求不高的链路】



强一致性（如 TCC、XA）
高性能最终一致性（可靠消息+补偿）
故障恢复
如果有服务挂掉或网络异常，事务管理器能根据日志做补偿、恢复。


- 分布式事务的解决方式: 
1. 两阶段提交（2PC, Two-Phase Prepare -> Commit）
2. TCC（Try-Confirm-Cancel）补偿事务
3. 基于消息驱动的最终一致性方案






  

 
 
